# Сервис назначения ревьюеров для Pull Request'ов

REST API сервис для автоматического назначения ревьюеров на Pull Request'ы. Управляет командами, пользователями и автоматически распределяет нагрузку по ревью между участниками.

## Что это?

Сервис решает задачу автоматического назначения ревьюверов на PR. При создании PR система автоматически выбирает до 2 активных участников из команды автора и назначает их ревьюверами. Также поддерживается переназначение ревьюверов, управление командами и массовая деактивация пользователей с безопасным переназначением открытых PR.

## Технологии

- **Язык**: Go 1.24
- **База данных**: PostgreSQL 15
- **Роутинг**: gorilla/mux
- **Миграции**: golang-migrate
- **Валидация**: go-playground/validator/v10
- **Моки**: mockery + testify/mock
- **Нагрузочное тестирование**: bombardier

## Быстрый старт

### Через Docker Compose (рекомендуется)

**Требования:**
- Docker Desktop (Windows/Mac) или Docker Engine + Docker Compose (Linux)
- Git

**Запуск:**

1. Склонируйте репозиторий:
```bash
git clone https://github.com/Rodjolo/PR-Reviewer-Assignment-Service.git
cd PR-Reviewer-Assignment-Service
```

2. (Опционально) Создайте `.env` файл, если нужны другие значения:
```bash
cp .env.example .env
# Отредактируйте .env при необходимости
```

3. Запустите проект:
```bash
docker-compose up --build
```

Сервис будет доступен на `http://localhost:8081`

**Примечание:** Файл `.env` не обязателен для запуска - `docker-compose.yml` использует безопасные значения по умолчанию

**Примечание о порте:** Сервис слушает на порту **8080 внутри контейнера** (как требуется заданием), но маппится на внешний порт **8081** для избежания конфликтов портов на хосте. Если порт 8080 на вашем хосте свободен, вы можете изменить маппинг в `docker-compose.yml` на `"8080:8080"`

**Важно для Windows:** Файл `docker-entrypoint.sh` должен иметь окончания строк LF (Unix), а не CRLF (Windows). Это обеспечивается автоматически через `.gitattributes`. Если возникает ошибка `exec /docker-entrypoint.sh: no such file or directory`, убедитесь, что файл был правильно склонирован из git

### Локальный запуск

1. Установите зависимости:
```bash
make deps
```

2. Запустите PostgreSQL (или используйте docker-compose только для БД):
```bash
docker-compose up postgres -d
```

3. Примените миграции:
```bash
make migrate-up
```

4. (Опционально) Заполните БД тестовыми данными:
```bash
make seed
```

5. Запустите сервер:
```bash
make run
```

## Структура проекта

Проект следует стандартной Go-структуре:

```
.
├── cmd/
│   ├── migrate/      # CLI утилита для миграций БД
│   └── server/        # Точка входа для HTTP сервера
├── internal/         # Внутренний код приложения
│   ├── database/     # Подключение и настройка БД
│   ├── handlers/     # HTTP handlers (разбиты по файлам)
│   ├── repository/   # Слой доступа к данным
│   ├── router/       # Настройка маршрутов
│   └── service/      # Бизнес-логика (с интерфейсами)
├── pkg/              # Публичные пакеты
│   ├── models/       # Модели данных
│   ├── dto/          # Структуры запросов/ответов
│   └── validator/    # Валидация запросов
├── mocks/            # Сгенерированные моки (не коммитятся)
├── migrations/       # SQL миграции
├── docker-compose.yml
├── Dockerfile
├── Makefile
└── openapi.yaml      # OpenAPI спецификация
```

## API Endpoints

### Pull Requests

- `POST /prs` - Создать PR (автоматически назначает до 2 ревьюверов)
- `GET /prs` - Список всех PR'ов
- `GET /prs?user_id={id}` - PR'ы пользователя (как автор или ревьюер)
- `GET /prs/{id}` - Получить PR по ID
- `PATCH /prs/{id}/reassign` - Переназначить ревьювера
- `POST /prs/{id}/merge` - Мержить PR

### Пользователи

- `POST /users` - Создать пользователя
- `GET /users` - Список всех пользователей
- `GET /users/{id}` - Получить пользователя по ID
- `PATCH /users/{id}` - Обновить пользователя

### Команды

- `POST /teams` - Создать команду
- `GET /teams` - Список всех команд
- `GET /teams/{name}` - Получить команду по имени
- `POST /teams/{name}/members` - Добавить участника в команду
- `DELETE /teams/{name}/members?user_id={id}` - Удалить участника из команды

### Статистика

- `GET /stats` - Получить статистику (количество пользователей, команд, PR'ов и т.д.)

### Swagger документация

- `GET /swagger/index.html` - Интерактивная Swagger UI документация

## Валидация запросов

Все входящие данные автоматически валидируются с использованием `go-playground/validator/v10`.

### Правила валидации

**Pull Requests:**
- `title`: обязательное поле, от 1 до 500 символов
- `author_id`: обязательное поле, должно быть больше 0

**Пользователи:**
- `name`: обязательное поле, от 1 до 100 символов

**Команды:**
- `name`: обязательное поле, от 1 до 50 символов

**Добавление участника:**
- `user_id`: обязательное поле, должно быть больше 0

**Переназначение ревьювера:**
- `old_reviewer_id`: обязательное поле, должно быть больше 0

### Формат ошибок валидации

При ошибке валидации API возвращает статус `400 Bad Request` с понятным сообщением:

```json
{
  "error": "title is required; author_id must be greater than 0"
}
```

## Правила назначения ревьюверов

### При создании PR:
1. Автоматически выбираются до 2 активных пользователей из команды автора
2. Автор исключается из кандидатов
3. Если активных меньше 2, назначаются только доступные (0/1)
4. Назначение случайное (ORDER BY RANDOM() в PostgreSQL)

### Переназначение:
- Заменяет одного ревьювера на случайного активного участника из **команды заменяемого ревьювера** (не из команды автора!)
- Автор PR также исключается из кандидатов

### После MERGED:
- Любые изменения ревьюверов запрещены
- Операции переназначения возвращают ошибку 409 Conflict

## Допущения и решения

При разработке возникли вопросы, которые не были явно описаны в требованиях. Вот что было решено:

### 1. Может ли пользователь быть в нескольких командах одновременно?

**Вопрос:** Не было явно указано, может ли один пользователь состоять в нескольких командах.

**Решение:** Один пользователь может быть только в одной команде.

**Обоснование:** 
- Упрощает логику назначения ревьюверов
- Соответствует типичным сценариям использования в реальных проектах
- Избегает неоднозначности при выборе команды для назначения ревьюверов
- Упрощает реализацию метода `GetUserTeam()` в репозитории

### 2. Что происходит при повторном вызове merge для уже мерженного PR?

**Вопрос:** Как должна вести себя операция merge, если PR уже имеет статус MERGED?

**Решение:** Merge - идемпотентная операция. Повторный merge уже мерженного PR возвращает успешный ответ (200 OK) с актуальным состоянием PR.

**Обоснование:**
- Соответствует принципам REST API (идемпотентность операций)
- Упрощает клиентскую логику (не нужно проверять статус перед merge)
- Предотвращает ошибки при повторных запросах
- Указано в требованиях как обязательное условие

### 3. Из какой команды выбирать нового ревьювера при переназначении?

**Вопрос:** При переназначении ревьювера, из какой команды должен выбираться новый ревьювер - из команды автора PR или из команды заменяемого ревьювера?

**Решение:** Новый ревьювер выбирается из команды **заменяемого ревьювера** (не из команды автора).

**Обоснование:**
- Это ключевое бизнес-правило, явно указанное в требованиях
- Логически обосновано: если ревьювер уходит из команды, его заменяет кто-то из той же команды
- Сохраняет баланс нагрузки между командами

### 4. Что делать, если в команде нет доступных ревьюверов?

**Вопрос:** Что происходит, если в команде автора нет активных пользователей (кроме самого автора) для назначения в качестве ревьюверов?

**Решение:** PR создается без ревьюверов (с пустым списком ревьюверов).

**Обоснование:**
- Допустимо согласно требованиям (назначается доступное количество: 0/1/2)
- Позволяет системе продолжать работу даже в неполных командах
- PR можно будет обработать позже, когда появятся активные участники

### 5. Как хранить статус PR в базе данных?

**Вопрос:** Какой тип данных использовать для статуса PR - ENUM, строка, или числовой код?

**Решение:** Статус хранится как строка ('OPEN' или 'MERGED') с CHECK constraint в БД.

**Обоснование:**
- Простота реализации и отладки (читаемые значения в БД)
- Легко расширять в будущем (добавление новых статусов)
- CHECK constraint гарантирует валидность данных на уровне БД
- Соответствует Go-стилю (использование строковых констант)

### 6. Должен ли автор PR исключаться из кандидатов при переназначении?

**Вопрос:** При переназначении ревьювера, должен ли автор PR также исключаться из кандидатов?

**Решение:** Да, автор PR исключается из кандидатов при переназначении.

**Обоснование:**
- Логически обосновано: автор не должен ревьювить свой собственный PR
- Соответствует правилу при создании PR
- Обеспечивает консистентность поведения системы

### 7. Как обрабатывать случай, когда пользователь не найден в команде при переназначении?

**Вопрос:** Что делать, если заменяемый ревьювер не состоит ни в какой команде?

**Решение:** Возвращается ошибка 404 "reviewer is not in any team".

**Обоснование:**
- Явная обработка граничного случая
- Предотвращает неопределенное поведение системы
- Позволяет клиенту понять причину ошибки

### 8. Нужно ли валидировать уникальность имен команд?

**Вопрос:** Должна ли система проверять уникальность имен команд при создании?

**Решение:** Да, имена команд должны быть уникальными. При попытке создать команду с существующим именем возвращается ошибка 409 Conflict.

**Обоснование:**
- Предотвращает путаницу и конфликты
- Соответствует RESTful практикам (409 для конфликтов)
- Упрощает поиск команд по имени

### 9. Как обрабатывать случай, когда пользователь пытается добавить себя в команду повторно?

**Вопрос:** Что происходит при попытке добавить пользователя в команду, в которой он уже состоит?

**Решение:** Используется `ON CONFLICT DO NOTHING` в SQL, операция завершается успешно без ошибки.

**Обоснование:**
- Идемпотентность операции (безопасно вызывать повторно)
- Упрощает клиентскую логику
- Избегает ненужных ошибок

### 10. Должен ли сервис поддерживать удаление пользователей или команд?

**Вопрос:** Нужны ли эндпоинты для удаления пользователей и команд?

**Решение:** Нет, удаление не реализовано, так как не было указано в требованиях.

**Обоснование:**
- Следование принципу YAGNI (You Aren't Gonna Need It)
- Фокус на реализации только требуемого функционала
- Упрощение API и снижение рисков (каскадные удаления могут быть сложными)

### 11. Как обрабатывать ошибки базы данных?

**Вопрос:** Какой уровень детализации ошибок возвращать клиенту?

**Решение:** Возвращаются понятные сообщения об ошибках без деталей внутренней реализации.

**Обоснование:**
- Безопасность (не раскрываем внутреннюю структуру БД)
- Удобство для клиентов (понятные сообщения)
- Соответствие best practices для REST API

### 12. Нужна ли пагинация для списковых эндпоинтов?

**Вопрос:** Должны ли эндпоинты `/users`, `/teams`, `/prs` поддерживать пагинацию?

**Решение:** Пагинация не реализована.

**Обоснование:**
- Требования указывают небольшой объем данных (до 20 команд, до 200 пользователей)
- Упрощает API и клиентскую логику
- Для указанных объемов пагинация не критична

## Переменные окружения

⚠️ **Важно:** Не храните пароли в коде! Используйте переменные окружения или файл `.env`.

Создайте `.env` на основе `.env.example`:
```bash
cp .env.example .env
# Отредактируйте .env и укажите реальные значения
```

Основные переменные:
- `DATABASE_URL` - строка подключения к PostgreSQL (обязательно!)
  - Формат: `postgres://username:password@host:port/database?sslmode=disable`
  - Пример: `postgres://postgres:your_password@localhost:5432/pr_reviewer?sslmode=disable`
- `PORT` - порт для HTTP сервера (по умолчанию: `8080`)
- `POSTGRES_USER` - пользователь PostgreSQL (для docker-compose)
- `POSTGRES_PASSWORD` - пароль PostgreSQL (для docker-compose)
- `POSTGRES_DB` - имя базы данных (для docker-compose)

## Makefile команды

- `make build` - собрать приложение
- `make run` - запустить сервер локально
- `make test` - запустить все тесты
- `make test-e2e` - запустить E2E тесты (требует тестовую БД)
- `make test-db-create` - создать тестовую БД для E2E тестов
- `make migrate-up` - применить миграции
- `make migrate-down` - откатить миграции
- `make seed` - заполнить БД тестовыми данными (пользователи и команды)
- `make docker-up` - запустить через docker-compose
- `make docker-down` - остановить docker-compose
- `make clean` - очистить бинарники и volumes
- `make deps` - установить зависимости
- `make swagger` - сгенерировать Swagger документацию
- `make install-mockery` - установить mockery для генерации моков
- `make generate-mocks` - сгенерировать моки из интерфейсов
- `make install-bombardier` - установить bombardier для нагрузочного тестирования
- `make load-test` - запустить нагрузочное тестирование (Linux/Mac)
- `make load-test-win` - запустить нагрузочное тестирование (Windows)
- `make load-test-quick` - быстрое тестирование только /stats
- `make load-test-simple` - упрощенное тестирование (PowerShell, без внешних зависимостей)

## Заполнение базы данных

### Автоматическое заполнение (рекомендуется)

После применения миграций можно заполнить БД тестовыми данными:

```bash
make seed
```

Это создаст:
- **6 пользователей** (5 активных: Alice, Bob, Charlie, David, Frank; 1 неактивный: Eve)
- **3 команды**: backend, frontend, devops
- **Распределение пользователей по командам**:
  - `backend`: Alice, Bob, Charlie
  - `frontend`: David, Frank
  - `devops`: Bob

### Ручное создание данных

Или создайте данные вручную через API:

```bash
# Создать пользователей
curl -X POST http://localhost:8080/users \
  -H "Content-Type: application/json" \
  -d '{"name": "Alice", "is_active": true}'

curl -X POST http://localhost:8080/users \
  -H "Content-Type: application/json" \
  -d '{"name": "Bob", "is_active": true}'

curl -X POST http://localhost:8080/users \
  -H "Content-Type: application/json" \
  -d '{"name": "Charlie", "is_active": true}'

# Создать команду
curl -X POST http://localhost:8080/teams \
  -H "Content-Type: application/json" \
  -d '{"name": "backend"}'

# Добавить участников в команду
curl -X POST http://localhost:8080/teams/backend/members \
  -H "Content-Type: application/json" \
  -d '{"user_id": 1}'

curl -X POST http://localhost:8080/teams/backend/members \
  -H "Content-Type: application/json" \
  -d '{"user_id": 2}'

curl -X POST http://localhost:8080/teams/backend/members \
  -H "Content-Type: application/json" \
  -d '{"user_id": 3}'
```

### Создание PR

```bash
curl -X POST http://localhost:8081/prs \
  -H "Content-Type: application/json" \
  -d '{"title": "Add new feature", "author_id": 1}'
```

PR автоматически получит до 2 случайных ревьюверов из команды автора.

### Переназначение ревьювера

```bash
curl -X PATCH http://localhost:8080/prs/1/reassign \
  -H "Content-Type: application/json" \
  -d '{"old_reviewer_id": 2}'
```

### Merge PR

```bash
curl -X POST http://localhost:8080/prs/1/merge
```

## Тестирование

### E2E тесты

Проект включает интеграционные (E2E) тесты, которые проверяют полный flow работы API через HTTP запросы.

**Требования:**
- PostgreSQL должен быть запущен
- Тестовая база данных `pr_reviewer_test` должна быть создана

**Настройка:**
```bash
# Создать тестовую БД
make test-db-create

# Или вручную
psql -U postgres -c "CREATE DATABASE pr_reviewer_test;"
```

**Запуск:**
```bash
# Запуск E2E тестов
make test-e2e

# Или напрямую
go test -v ./test/e2e/... -timeout 30s
```

**Что тестируется:**
- Создание и получение пользователей
- Создание команд и управление участниками
- Создание PR с автоматическим назначением ревьюверов
- Переназначение ревьюверов
- Merge PR и проверка ограничений
- Массовая деактивация команды
- Получение статистики

Подробнее см. [test/e2e/README.md](test/e2e/README.md)

### Unit тесты

Проект включает unit-тесты для service layer с покрытием 76.4%.

**Запуск:**
```bash
# Запуск всех тестов (включая unit)
make test

# Запуск только service layer тестов с покрытием
go test ./internal/service/... -cover
```

**Моки:**
- Моки генерируются автоматически через [mockery](https://vektra.github.io/mockery/)
- Находятся в директории `mocks/`
- Генерируются из интерфейсов в `internal/repository/interfaces.go`

**Генерация моков:**
```bash
# Установка mockery
make install-mockery

# Генерация моков
make generate-mocks
```

**Конфигурация:**
- Настройки mockery находятся в `.mockery.yaml`
- Моки используют `testify/mock` для assertion'ов
- Все моки включают expecter API для удобства

## Swagger документация

После запуска сервиса Swagger UI доступен по адресу:
- **http://localhost:8080/swagger/index.html**

Документация генерируется автоматически при сборке Docker образа. Для локальной разработки используйте:
```bash
make swagger
```

## Нагрузочное тестирование

Для проведения нагрузочного тестирования используется [bombardier](https://github.com/codesenberg/bombardier).

### Установка bombardier

```bash
make install-bombardier
# или
go install github.com/codesenberg/bombardier@latest
```

### Запуск тестов

**Важно:** Перед тестированием убедитесь, что Docker Desktop запущен и сервис доступен:
```bash
docker-compose up -d
curl http://localhost:8080/stats
```

**Linux/Mac:**
```bash
make load-test
```

**Windows:**
```bash
make load-test-win
```

**Быстрый тест (только /stats):**
```bash
make load-test-quick
```

**Упрощенный вариант (без внешних зависимостей, PowerShell):**
```bash
make load-test-simple
```

Если возникают проблемы, см. подробную инструкцию в [LOAD_TESTING.md](LOAD_TESTING.md)

### Настройка параметров

Можно настроить параметры через переменные окружения:

```bash
# Linux/Mac
CONCURRENT=100 REQUESTS=50000 make load-test

# Windows PowerShell
$env:CONCURRENT=100; $env:REQUESTS=50000; make load-test-win
```

Параметры по умолчанию:
- Concurrent connections: 50
- Total requests: 20000

### Пример результатов

```
Statistics        Avg      Stdev        Max
  Reqs/sec      5000.00    500.00    5500.00
  Latency       10.00ms    2.00ms    50.00ms
  HTTP codes:
    1xx - 0, 2xx - 20000, 3xx - 0, 4xx - 0, 5xx - 0
```

## Производительность

Сервис рассчитан на умеренные нагрузки:
- До 20 команд
- До 200 пользователей
- 5 RPS (фактически показывает 6,893-11,645 RPS)
- SLI 300 мс (фактически 4-7 мс)
- Доступность 99.9% (фактически 100% - 0 ошибок 5xx)

Все требования выполнены с большим запасом.

### Результаты нагрузочного тестирования

Тестирование проводилось с параметрами:
- **Concurrent connections**: 50
- **Total requests**: 20,000 на каждый эндпоинт
- **Инструмент**: bombardier

#### Результаты по эндпоинтам (после оптимизации):

**1. GET /stats (статистика)**
- ✅ **Успешность**: 100% (20,000/20,000) - **0 ошибок 5xx**
- **RPS**: 6,893 req/s (среднее) - **в 1,378 раз выше требования (5 RPS)**
- **Latency**: 7.22ms (среднее), 194.43ms (максимум) - **в 41 раз быстрее SLI (300ms)**
- **Throughput**: 1.76 MB/s
- **Статус**: ✅ Отлично работает под нагрузкой

**2. GET /users (список пользователей)**
- ✅ **Успешность**: 100% (20,000/20,000) - **0 ошибок 5xx**
- **RPS**: 11,497 req/s (среднее) - **в 2,299 раз выше требования**
- **Latency**: 4.29ms (среднее), 96.76ms (максимум) - **в 70 раз быстрее SLI**
- **Throughput**: 4.68 MB/s
- **Статус**: ✅ Отлично работает под нагрузкой

**3. GET /teams (список команд)**
- ✅ **Успешность**: 100% (20,000/20,000) - **0 ошибок 5xx** (было 93.7%)
- **RPS**: 7,416 req/s (среднее) - **в 1,483 раз выше требования**
- **Latency**: 6.69ms (среднее), 138.12ms (максимум) - **в 45 раз быстрее SLI**
- **Throughput**: 3.66 MB/s
- **Статус**: ✅ Полностью исправлено после оптимизации

**4. GET /prs (список всех PR)**
- ✅ **Успешность**: 100% (20,000/20,000) - **0 ошибок 5xx** (было 61.5%)
- **RPS**: 11,645 req/s (среднее) - **в 2,329 раз выше требования**
- **Latency**: 4.24ms (среднее), 130.27ms (максимум) - **в 71 раз быстрее SLI**
- **Throughput**: 1.98 MB/s
- **Статус**: ✅ Полностью исправлено после оптимизации

**5. GET /prs?user_id=1 (PR по пользователю)**
- ✅ **Успешность**: 100% (20,000/20,000) - **0 ошибок 5xx** (было 71.9%)
- **RPS**: 8,270 req/s (среднее) - **в 1,654 раз выше требования**
- **Latency**: 5.98ms (среднее), 122.90ms (максимум) - **в 50 раз быстрее SLI**
- **Throughput**: 1.48 MB/s
- **Статус**: ✅ Полностью исправлено после оптимизации

#### Итоги

Все эндпоинты показывают отличные результаты:
- 100% успешность (0 ошибок 5xx)
- Все эндпоинты превышают требуемые 5 RPS
- Все укладываются в SLI 300 мс
- SLI успешности 99.9% достигнут (фактически 100%)

#### Выполненные оптимизации

- Увеличен пул соединений БД (25 → 100)
- Оптимизированы запросы: разделение на два запроса вместо больших JOIN
- Использование `pq.Array` для работы с массивами в PostgreSQL
  - **Важно**: Все запросы с `ANY`/`ALL` используют `pq.Array()` для предотвращения ошибок типа `unsupported type []int`
  - Критично для стабильности под высокой нагрузкой
- Исправлен `GetStats()` для корректного сканирования результатов
- Устранены все ошибки 5xx

**Примечание для разработчиков:**
При добавлении новых запросов с `ANY`/`ALL` в PostgreSQL всегда используйте `pq.Array()` для массивов Go, чтобы избежать ошибок типа `unsupported type []int` под нагрузкой.

## Линтер

Проект использует [golangci-lint](https://golangci-lint.run/) - агрегатор линтеров для Go.

### Установка

**Linux/Mac:**
```bash
make install-linter
# или
go install github.com/golangci/golangci-lint/cmd/golangci-lint@latest
```

**Windows (рекомендуется - через бинарник):**
```bash
# Скачать и распаковать последнюю версию
make install-linter-win
```

**Windows (альтернатива - ручная установка):**
1. Скачайте последний релиз с [GitHub](https://github.com/golangci/golangci-lint/releases)
2. Распакуйте и добавьте `golangci-lint.exe` в PATH
3. Или поместите в `%GOPATH%\bin\`

**Если `go install` не работает** (проблемы с сетью/зависимостями), используйте установку через бинарник.

**Примечание**: При возникновении ошибок совместимости версий Go и golangci-lint, используйте встроенные инструменты Go:

```bash
# Базовая проверка
go vet ./...

# Форматирование
gofmt -l -s .

# Поиск ошибок
go build ./...
```

### Использование

**Проверка кода:**
```bash
make lint
# или
golangci-lint run ./...
```

**Проверка с автоисправлением:**
```bash
make lint-fix
# или
golangci-lint run --fix ./...
```

**Если golangci-lint не работает** (проблемы совместимости версий):
```bash
# Используйте встроенные инструменты Go
go vet ./internal/... ./pkg/...
gofmt -l -s ./internal ./pkg
go build ./...
```

### Конфигурация

Конфигурация линтера находится в файле `.golangci.yml`. Включенные линтеры:

**Базовые проверки:**
- `errcheck` - проверка необработанных ошибок
- `gosimple` - упрощение кода
- `govet` - проверка подозрительных конструкций
- `ineffassign` - неэффективные присваивания
- `staticcheck` - набор статических проверок
- `unused` - неиспользуемый код

**Стиль кода:**
- `gofmt` - форматирование
- `goimports` - форматирование импортов
- `misspell` - орфографические ошибки
- `revive` - стиль кода

**Обработка ошибок:**
- `goerr113` - проверка по Go 1.13+
- `errname` - именование переменных ошибок

**Производительность:**
- `prealloc` - преаллокация срезов

**Безопасность:**
- `gosec` - проблемы безопасности

**SQL:**
- `rowserrcheck` - обработка ошибок sql.Rows.Err()
- `sqlclosecheck` - закрытие sql.Rows и sql.Stmt

Тесты исключены из некоторых проверок для большей гибкости.


