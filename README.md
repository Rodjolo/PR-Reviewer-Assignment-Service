# Сервис назначения ревьюеров для Pull Request'ов

Микросервис для автоматического назначения ревьюеров на Pull Request'ы с управлением командами и участниками.

## Описание

Сервис предоставляет REST API для:
- Автоматического назначения ревьюеров на PR из команды автора
- Переназначения ревьюверов
- Получения списка PR'ов по пользователю
- Управления командами и активностью пользователей

## Технологии

- **Язык**: Go 1.21
- **База данных**: PostgreSQL 15
- **Роутинг**: gorilla/mux
- **Миграции**: golang-migrate

## Быстрый старт

### Через Docker Compose (рекомендуется)

```bash
docker-compose up --build
```

Сервис будет доступен на `http://localhost:8080`

### Локальный запуск

1. Установите зависимости:
```bash
make deps
```

2. Запустите PostgreSQL (или используйте docker-compose только для БД):
```bash
docker-compose up postgres -d
```

3. Примените миграции:
```bash
make migrate-up
```

4. (Опционально) Заполните БД тестовыми данными:
```bash
make seed
```

5. Запустите сервер:
```bash
make run
```

## Структура проекта

```
.
├── cmd/
│   ├── migrate/      # Утилита для миграций
│   └── server/        # Основной сервер
├── internal/
│   ├── database/     # Подключение к БД
│   ├── handlers/     # HTTP handlers
│   ├── models/       # Модели данных
│   ├── repository/   # Репозитории для работы с БД
│   ├── router/       # Роутинг
│   └── service/      # Бизнес-логика
├── migrations/       # SQL миграции
├── docker-compose.yml
├── Dockerfile
├── Makefile
└── openapi.yaml      # OpenAPI спецификация
```

## API Endpoints

### Pull Requests

- `POST /prs` - Создать PR (автоматически назначает до 2 ревьюверов)
- `GET /prs` - Список всех PR'ов
- `GET /prs?user_id={id}` - PR'ы пользователя (как автор или ревьюер)
- `GET /prs/{id}` - Получить PR по ID
- `PATCH /prs/{id}/reassign` - Переназначить ревьювера
- `POST /prs/{id}/merge` - Мержить PR

### Пользователи

- `POST /users` - Создать пользователя
- `GET /users` - Список всех пользователей
- `GET /users/{id}` - Получить пользователя по ID
- `PATCH /users/{id}` - Обновить пользователя

### Команды

- `POST /teams` - Создать команду
- `GET /teams` - Список всех команд
- `GET /teams/{name}` - Получить команду по имени
- `POST /teams/{name}/members` - Добавить участника в команду
- `DELETE /teams/{name}/members?user_id={id}` - Удалить участника из команды

### Статистика

- `GET /stats` - Получить статистику (количество пользователей, команд, PR'ов и т.д.)

### Swagger документация

- `GET /swagger/index.html` - Интерактивная Swagger UI документация

## Правила назначения ревьюверов

### При создании PR:
1. Автоматически выбираются до 2 активных пользователей из команды автора
2. Автор исключается из кандидатов
3. Если активных меньше 2, назначаются только доступные (0/1)
4. Назначение случайное (ORDER BY RANDOM() в PostgreSQL)

### Переназначение:
- Заменяет одного ревьювера на случайного активного участника из **команды заменяемого ревьювера** (не из команды автора!)
- Автор PR также исключается из кандидатов

### После MERGED:
- Любые изменения ревьюверов запрещены
- Операции переназначения возвращают ошибку 409 Conflict

## Допущения и решения

В процессе разработки возникли вопросы, которые не были явно описаны в требованиях. Ниже приведен список таких вопросов и принятые решения:

### 1. Может ли пользователь быть в нескольких командах одновременно?

**Вопрос:** Не было явно указано, может ли один пользователь состоять в нескольких командах.

**Решение:** Один пользователь может быть только в одной команде.

**Обоснование:** 
- Упрощает логику назначения ревьюверов
- Соответствует типичным сценариям использования в реальных проектах
- Избегает неоднозначности при выборе команды для назначения ревьюверов
- Упрощает реализацию метода `GetUserTeam()` в репозитории

### 2. Что происходит при повторном вызове merge для уже мерженного PR?

**Вопрос:** Как должна вести себя операция merge, если PR уже имеет статус MERGED?

**Решение:** Merge - идемпотентная операция. Повторный merge уже мерженного PR возвращает успешный ответ (200 OK) с актуальным состоянием PR.

**Обоснование:**
- Соответствует принципам REST API (идемпотентность операций)
- Упрощает клиентскую логику (не нужно проверять статус перед merge)
- Предотвращает ошибки при повторных запросах
- Указано в требованиях как обязательное условие

### 3. Из какой команды выбирать нового ревьювера при переназначении?

**Вопрос:** При переназначении ревьювера, из какой команды должен выбираться новый ревьювер - из команды автора PR или из команды заменяемого ревьювера?

**Решение:** Новый ревьювер выбирается из команды **заменяемого ревьювера** (не из команды автора).

**Обоснование:**
- Это ключевое бизнес-правило, явно указанное в требованиях
- Логически обосновано: если ревьювер уходит из команды, его заменяет кто-то из той же команды
- Сохраняет баланс нагрузки между командами

### 4. Что делать, если в команде нет доступных ревьюверов?

**Вопрос:** Что происходит, если в команде автора нет активных пользователей (кроме самого автора) для назначения в качестве ревьюверов?

**Решение:** PR создается без ревьюверов (с пустым списком ревьюверов).

**Обоснование:**
- Допустимо согласно требованиям (назначается доступное количество: 0/1/2)
- Позволяет системе продолжать работу даже в неполных командах
- PR можно будет обработать позже, когда появятся активные участники

### 5. Как хранить статус PR в базе данных?

**Вопрос:** Какой тип данных использовать для статуса PR - ENUM, строка, или числовой код?

**Решение:** Статус хранится как строка ('OPEN' или 'MERGED') с CHECK constraint в БД.

**Обоснование:**
- Простота реализации и отладки (читаемые значения в БД)
- Легко расширять в будущем (добавление новых статусов)
- CHECK constraint гарантирует валидность данных на уровне БД
- Соответствует Go-стилю (использование строковых констант)

### 6. Должен ли автор PR исключаться из кандидатов при переназначении?

**Вопрос:** При переназначении ревьювера, должен ли автор PR также исключаться из кандидатов?

**Решение:** Да, автор PR исключается из кандидатов при переназначении.

**Обоснование:**
- Логически обосновано: автор не должен ревьювить свой собственный PR
- Соответствует правилу при создании PR
- Обеспечивает консистентность поведения системы

### 7. Как обрабатывать случай, когда пользователь не найден в команде при переназначении?

**Вопрос:** Что делать, если заменяемый ревьювер не состоит ни в какой команде?

**Решение:** Возвращается ошибка 404 "reviewer is not in any team".

**Обоснование:**
- Явная обработка граничного случая
- Предотвращает неопределенное поведение системы
- Позволяет клиенту понять причину ошибки

### 8. Нужно ли валидировать уникальность имен команд?

**Вопрос:** Должна ли система проверять уникальность имен команд при создании?

**Решение:** Да, имена команд должны быть уникальными. При попытке создать команду с существующим именем возвращается ошибка 409 Conflict.

**Обоснование:**
- Предотвращает путаницу и конфликты
- Соответствует RESTful практикам (409 для конфликтов)
- Упрощает поиск команд по имени

### 9. Как обрабатывать случай, когда пользователь пытается добавить себя в команду повторно?

**Вопрос:** Что происходит при попытке добавить пользователя в команду, в которой он уже состоит?

**Решение:** Используется `ON CONFLICT DO NOTHING` в SQL, операция завершается успешно без ошибки.

**Обоснование:**
- Идемпотентность операции (безопасно вызывать повторно)
- Упрощает клиентскую логику
- Избегает ненужных ошибок

### 10. Должен ли сервис поддерживать удаление пользователей или команд?

**Вопрос:** Нужны ли эндпоинты для удаления пользователей и команд?

**Решение:** Нет, удаление не реализовано, так как не было указано в требованиях.

**Обоснование:**
- Следование принципу YAGNI (You Aren't Gonna Need It)
- Фокус на реализации только требуемого функционала
- Упрощение API и снижение рисков (каскадные удаления могут быть сложными)

### 11. Как обрабатывать ошибки базы данных?

**Вопрос:** Какой уровень детализации ошибок возвращать клиенту?

**Решение:** Возвращаются понятные сообщения об ошибках без деталей внутренней реализации.

**Обоснование:**
- Безопасность (не раскрываем внутреннюю структуру БД)
- Удобство для клиентов (понятные сообщения)
- Соответствие best practices для REST API

### 12. Нужна ли пагинация для списковых эндпоинтов?

**Вопрос:** Должны ли эндпоинты `/users`, `/teams`, `/prs` поддерживать пагинацию?

**Решение:** Пагинация не реализована.

**Обоснование:**
- Требования указывают небольшой объем данных (до 20 команд, до 200 пользователей)
- Упрощает API и клиентскую логику
- Для указанных объемов пагинация не критична

## Переменные окружения

**ВАЖНО:** Для безопасности используйте переменные окружения или файл `.env`. Не храните пароли в коде!

Создайте файл `.env` на основе `.env.example`:
```bash
cp .env.example .env
# Отредактируйте .env и укажите реальные пароли
```

Переменные окружения:
- `DATABASE_URL` - строка подключения к PostgreSQL (обязательно!)
  - Формат: `postgres://username:password@host:port/database?sslmode=disable`
  - Пример: `postgres://postgres:your_password@localhost:5432/pr_reviewer?sslmode=disable`
- `PORT` - порт для HTTP сервера (по умолчанию: `8080`)
- `POSTGRES_USER` - пользователь PostgreSQL (для docker-compose)
- `POSTGRES_PASSWORD` - пароль PostgreSQL (для docker-compose)
- `POSTGRES_DB` - имя базы данных (для docker-compose)

## Makefile команды

- `make build` - собрать приложение
- `make run` - запустить сервер локально
- `make test` - запустить тесты
- `make migrate-up` - применить миграции
- `make migrate-down` - откатить миграции
- `make seed` - заполнить БД тестовыми данными (пользователи и команды)
- `make docker-up` - запустить через docker-compose
- `make docker-down` - остановить docker-compose
- `make clean` - очистить бинарники и volumes
- `make deps` - установить зависимости
- `make swagger` - сгенерировать Swagger документацию
- `make install-bombardier` - установить bombardier для нагрузочного тестирования
- `make load-test` - запустить нагрузочное тестирование (Linux/Mac)
- `make load-test-win` - запустить нагрузочное тестирование (Windows)
- `make load-test-quick` - быстрое тестирование только /stats
- `make load-test-simple` - упрощенное тестирование (PowerShell, без внешних зависимостей)

## Заполнение базы данных

### Автоматическое заполнение (рекомендуется)

После применения миграций можно заполнить БД тестовыми данными:

```bash
make seed
```

Это создаст:
- **6 пользователей** (5 активных: Alice, Bob, Charlie, David, Frank; 1 неактивный: Eve)
- **3 команды**: backend, frontend, devops
- **Распределение пользователей по командам**:
  - `backend`: Alice, Bob, Charlie
  - `frontend`: David, Frank
  - `devops`: Bob

### Ручное создание данных

Или создайте данные вручную через API:

```bash
# Создать пользователей
curl -X POST http://localhost:8080/users \
  -H "Content-Type: application/json" \
  -d '{"name": "Alice", "is_active": true}'

curl -X POST http://localhost:8080/users \
  -H "Content-Type: application/json" \
  -d '{"name": "Bob", "is_active": true}'

curl -X POST http://localhost:8080/users \
  -H "Content-Type: application/json" \
  -d '{"name": "Charlie", "is_active": true}'

# Создать команду
curl -X POST http://localhost:8080/teams \
  -H "Content-Type: application/json" \
  -d '{"name": "backend"}'

# Добавить участников в команду
curl -X POST http://localhost:8080/teams/backend/members \
  -H "Content-Type: application/json" \
  -d '{"user_id": 1}'

curl -X POST http://localhost:8080/teams/backend/members \
  -H "Content-Type: application/json" \
  -d '{"user_id": 2}'

curl -X POST http://localhost:8080/teams/backend/members \
  -H "Content-Type: application/json" \
  -d '{"user_id": 3}'
```

### Создание PR

```bash
curl -X POST http://localhost:8080/prs \
  -H "Content-Type: application/json" \
  -d '{"title": "Add new feature", "author_id": 1}'
```

PR автоматически получит до 2 случайных ревьюверов из команды автора.

### Переназначение ревьювера

```bash
curl -X PATCH http://localhost:8080/prs/1/reassign \
  -H "Content-Type: application/json" \
  -d '{"old_reviewer_id": 2}'
```

### Merge PR

```bash
curl -X POST http://localhost:8080/prs/1/merge
```

## Swagger документация

После запуска сервиса Swagger UI доступен по адресу:
- **http://localhost:8080/swagger/index.html**

Документация генерируется автоматически при сборке Docker образа. Для локальной разработки используйте:
```bash
make swagger
```

## Нагрузочное тестирование

Для проведения нагрузочного тестирования используется [bombardier](https://github.com/codesenberg/bombardier).

### Установка bombardier

```bash
make install-bombardier
# или
go install github.com/codesenberg/bombardier@latest
```

### Запуск тестов

**Важно:** Перед тестированием убедитесь, что Docker Desktop запущен и сервис доступен:
```bash
docker-compose up -d
curl http://localhost:8080/stats
```

**Linux/Mac:**
```bash
make load-test
```

**Windows:**
```bash
make load-test-win
```

**Быстрый тест (только /stats):**
```bash
make load-test-quick
```

**Упрощенный вариант (без внешних зависимостей, PowerShell):**
```bash
make load-test-simple
```

Если возникают проблемы, см. подробную инструкцию в [LOAD_TESTING.md](LOAD_TESTING.md)

### Настройка параметров

Можно настроить параметры через переменные окружения:

```bash
# Linux/Mac
CONCURRENT=100 REQUESTS=50000 make load-test

# Windows PowerShell
$env:CONCURRENT=100; $env:REQUESTS=50000; make load-test-win
```

Параметры по умолчанию:
- Concurrent connections: 50
- Total requests: 20000

### Пример результатов

```
Statistics        Avg      Stdev        Max
  Reqs/sec      5000.00    500.00    5500.00
  Latency       10.00ms    2.00ms    50.00ms
  HTTP codes:
    1xx - 0, 2xx - 20000, 3xx - 0, 4xx - 0, 5xx - 0
```

## Производительность

Сервис рассчитан на:
- До 20 команд
- До 200 пользователей
- 5 RPS
- SLI 300 мс
- Доступность 99.9%


